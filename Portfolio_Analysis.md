# SoulLike 프로젝트 포트폴리오 분석

## 핵심 어필 포인트 5가지

### 1. 게임플레이 어빌리티 시스템(GAS) 기반의 정교한 전투 및 스탯 시스템 구축

*   **근거:**
    *   `SoulLikeAbilityTypes.h`, `SoulLikeGameplayTags.h`에서 볼 수 있듯이, Primary/Secondary/Resistance/Vital/Boost 등 **세분화된 어트리뷰트 시스템**을 직접 설계하고 구현했습니다.
    *   데미지 계산에 필요한 모든 스탯(저항, 부스트, 주요 스탯 등)을 `FSoulLikeExecCalcCaptureStatics` 구조체를 통해 **미리 캐싱하고 최적화**하여, 복잡한 데미지 공식을 효율적으로 처리합니다.
    *   `FSoulLikeGameplayEffectContext`를 확장하여 데미지 타입, 강인도, 넉백 등 **전투에 필요한 추가 데이터를 유연하게 전달**함으로써, 단순한 수치 교환을 넘어선 깊이 있는 전투 상호작용을 구현했습니다.
*   **어필 포인트:**
    > "단순히 GAS를 사용하는 것을 넘어, 시스템의 핵심 클래스인 `FGameplayEffectContext`와 `UGameplayEffectExecutionCalculation`을 깊이 이해하고 프로젝트에 맞게 커스터마이징했습니다. 이를 통해 **확장성 높고 데이터 기반으로 밸런싱이 용이한 정교한 전투 시스템**을 구축할 수 있는 역량을 증명합니다."

### 2. Enhanced Input과 게임플레이 태그를 연동한 유연하고 확장 가능한 입력 시스템

*   **근거:**
    *   `SoulLikeInputConfig.h`의 `USoulLikeInputConfig` 데이터 애셋은 **입력 액션(InputAction)과 게임플레이 태그(InputTag)를 1:1로 매핑**합니다.
    *   이를 통해 `InputTag`만으로 원하는 입력 액션을 찾아 어빌리티를 활성화하거나, 특정 입력에 대한 로직을 수행할 수 있습니다.
*   **어필 포인트:**
    > "언리얼 엔진 5의 Enhanced Input 시스템을 능숙하게 활용하며, 이를 게임플레이 태그와 결합하여 **입력과 어빌리티/액션을 완벽하게 분리**했습니다. 덕분에 새로운 입력이나 기능을 추가할 때 코드 변경을 최소화하고, 디자이너가 데이터 애셋 수정만으로 입력을 관리할 수 있는 **유연하고 확장성 높은 입력 시스템**을 설계했습니다."

### 3. 행동 트리(Behavior Tree)와 AI 감지(AI Perception)를 활용한 지능적인 AI 설계

*   **근거:**
    *   `SoulLikeAIController.h`는 `UBehaviorTreeComponent`를 사용하여 AI의 행동 로직을 관리합니다.
    *   `UAISenseConfig_Sight`(시각)와 `UAISenseConfig_Damage`(피격)를 사용하여 **주변 환경과 플레이어의 행동을 감지**하고, `OnTargetPerceptionUpdated`와 같은 이벤트를 통해 AI의 행동을 동적으로 변화시킵니다.
    *   `IGenericTeamAgentInterface`를 구현하여 **피아 식별(Team Attitude)** 로직을 명확하게 처리합니다.
*   **어필 포인트:**
    > "행동 트리와 AI 감지 시스템을 결합하여 **상황에 따라 능동적으로 대처하는 지능적인 AI**를 구현했습니다. 플레이어를 발견하고 추격하며, 전투 상황에 돌입하는 등 소울라이크 장르에 필수적인 긴장감 넘치는 AI 로직을 설계하고 구현할 수 있는 역량을 보여줍니다."

### 4. 인터페이스(Interface)를 활용한 객체지향적 상호작용 시스템

*   **근거:**
    *   `SoulLikeCharacter.h`는 `IPlayerInterface`와 `IInteractionInterface`를 상속받아 다양한 상호작용을 처리합니다.
    *   `Interaction_Implementation` 함수와 `OnBeginOverlap`/`OnEndOverlap` 이벤트를 통해 **상호작용 가능한 액터를 감지하고, 해당 액터의 종류에 맞는 로직을 수행**합니다.
    *   `GetInteractionTag`와 같은 함수를 통해 현재 상호작용의 종류를 태그로 반환하여, 유연한 로직 분기를 가능하게 합니다.
*   **어필 포인트:**
    > "C++ 인터페이스를 적극적으로 활용하여 **클래스 간의 의존성을 낮추고 재사용성을 높인 상호작용 시스템**을 구축했습니다. 이를 통해 사다리, 아이템, NPC 등 새로운 상호작용 오브젝트를 추가할 때 기존 코드에 미치는 영향을 최소화하는 **객체지향적이고 확장 가능한 아키텍처 설계 능력**을 증명합니다."

### 5. 체계적인 게임플레이 태그 시스템을 통한 상태 관리 및 이벤트 기반 아키텍처 구현

*   **근거:**
    *   `SoulLikeGameplayTags.h`에 정의된 방대한 양의 태그는 캐릭터/AI의 상태, 입력, 이벤트, 아이템 타입 등 **게임의 거의 모든 요소를 체계적으로 분류하고 관리**하는 데 사용됩니다.
    *   `Status_Rolling`, `Status_TargetLock`, `Event_Montage_NextAction` 등 특정 상태나 이벤트를 태그로 정의하고, 이 태그의 유무에 따라 어빌리티를 활성화하거나 로직을 실행하는 **이벤트 기반 아키텍처**를 구현했습니다.
*   **어필 포인트:**
    > "게임플레이 태그를 단순한 식별자를 넘어, **게임 전체의 상태를 관리하고 로직을 구동하는 핵심적인 아키텍처**로 활용했습니다. 이를 통해 복잡한 게임 로직을 명확하고 직관적으로 관리하며, 디버깅과 유지보수가 용이한 코드를 작성하는 역량을 보여줍니다. 이는 대규모 프로젝트에서 필수적인 **체계적인 시스템 설계 능력**을 어필할 수 있는 강력한 요소입니다."
